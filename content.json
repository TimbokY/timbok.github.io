{"meta":{"title":"Timbok's Blog","subtitle":"B.Y'S BLOG","description":"看到这段话说明你也是个IT工作者，这里有很多不错的技术博，希望和大家成为朋友，互相进步。","author":"Timbok","url":"https://yb909144903.github.io"},"pages":[{"title":"文章分类","date":"2018-11-29T08:08:09.000Z","updated":"2018-11-29T11:22:15.403Z","comments":false,"path":"categories/index.html","permalink":"https://yb909144903.github.io/categories/index.html","excerpt":"","text":""},{"title":"Photo","date":"2018-11-29T08:33:26.000Z","updated":"2018-11-29T08:33:26.820Z","comments":true,"path":"photo/index.html","permalink":"https://yb909144903.github.io/photo/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2018-11-29T11:24:59.000Z","updated":"2018-12-02T08:23:17.810Z","comments":true,"path":"introduce/index.html","permalink":"https://yb909144903.github.io/introduce/index.html","excerpt":"","text":"Timbok(yb909144903@gmail.com)个人信息 学历：本科 专业：软件工程 职业：web前端小白 发量：茂盛 技术博客：https://timbok.top 地点： 上海 项目经历 ████████████████████ ████████████████████ ████████████████████ ████████████████████ 技能列表 熟悉vueJS、React等主流MVC、MVVM框架； 掌握localStorage、sessionStorage等前端存储方案，记录用户操作习惯或常用数据，从而降低HTTP请求，提升用户体验； 熟练使用SVN、git版本控制工具，进行代码管理，实现敏捷开发； 熟练使用Bootstarp框架，通过栅格系统快速布局响应式页面以适应 不同设备； 熟练使用Ajax，实现异步页面无刷新抽取数据，同步校验数据； 熟练使用HTML、CSS、JavaScript等前端技术，完成网页静态布局， 开发兼容主流浏览器的页面，以及实现页面的交互，提升用户体验； 了解node.js，利用其搭建简单的服务器。 个人爱好 吃饭、睡觉、打豆豆 打LOL"}],"posts":[{"title":"react打怪笔记","slug":"react打怪笔记","date":"2018-12-19T08:39:01.000Z","updated":"2018-12-19T08:44:12.331Z","comments":true,"path":"2018/12/19/react打怪笔记/","link":"","permalink":"https://yb909144903.github.io/2018/12/19/react打怪笔记/","excerpt":"","text":"介绍本文用于记录在学习react中的记录。 Tips: 当组件的props或state有变化，执行render函数。 无论是使用函数或是类来声明一个组件，它决不能修改它自己的props 无状态函数式组件 (stateless functional component)例: 12345678910111213141516&lt;!--this--&gt;function Welcome(props) &#123; return &lt;p&gt;hello, &#123;props.name&#125;&lt;/p&gt;;&#125;&lt;!--or ES6--&gt;const Welcome = (&#123; name &#125;) =&gt; &#123; return &lt;p&gt;hello, &#123;props.name&#125;&lt;/p&gt;;&#125;const element = &lt;Welcome name=\"Timbok\" /&gt;ReactDom.render( element, document.getElementById('root'),) 无生命周期方法函数式组件，有时也被称为无状态组件，没有任何生命周期方法，意味着每次上层组件树状态发生变更时它们都会重新渲染，这就是因为缺少 ==shouldComponentUpdate== 方法导致的。这也同样意味着您不能定义某些基于组件挂载和卸载的行为。 没有 this 和 ref更有趣的是您在函数式组件中既不能使用 ==this==关键字或访问到 ==ref==。对于习惯了严格意义上的类或面向对象风格的人来说，这很让他们惊讶。这也是使用函数最大的争论点。另一个有趣的事实就是您仍然可以访问到 context，如果您将 context 定义为函数的一个 props。 避免常见陷阱在编写无状态函数式组件时，您需要避免某些特定的模式。避免在函数式组件中定义函数，这是因为每一次函数式组件被调用的时候，一个新的函数都会被创建。 123456const Functional = (&#123;...&#125;) =&gt; &#123; const handleSomething = e =&gt; path(['event', 'target'], e) return ( // ... )&#125; 这个问题很容易解决，您可以将这个函数作为 props 传递进去，或者将它定义在组件外面。 12const handleSomething = e =&gt; path(['event', 'target'], e)const Functional = (&#123;...&#125;) =&gt; // ... 生命周期概况 生命周期演示 1.初始化在组件初始化阶段会执行 constructor static getDerivedStateFromProps() componentWillMount() / UNSAFE_componentWillMount() render() componentDidMount() 2.更新阶段props或state的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法： componentWillReceiveProps() / UNSAFE_componentWillReceiveProps() static getDerivedStateFromProps() shouldComponentUpdate() componentWillUpdate() / UNSAFE_componentWillUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 3.卸载阶段 componentWillUnmount() 4.错误处理 componentDidCatch() 详解1.constructor(props)react组件的构造函数在挂载之前被调用。在实现React.Component构造函数时，需要先在添加其他内容前，调用super(props)，用来将父组件传来的props绑定到这个类中，使用this.props将会得到。 官方建议不要在constructor引入任何具有副作用和订阅功能的代码，这些应当在componentDidMount()中写入。 constructor中应当做些初始化的动作，如：初始化state，将事件处理函数绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。 当然也可以利用props初始化state，在之后修改state不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用redux统一进行状态管理。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; 2.static getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps在组件实例化后，和接受新的props后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。 如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。 调用steState()不会触发getDerivedStateFromProps()。 3. componentWillMount() / UNSAFE_componentWillMount()componentWillMount()将在react未来版本中被弃用。UNSAFE_componentWillMount()在组件挂载前被调用，在这个方法中调用setState()不会起作用，是由于他在render()前被调用。 为了避免副作用和其他的订阅，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。 4.render()render()方法是必需的。当他被调用时，他将计算this.props和this.state，并返回以下一种类型： React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。 字符串或数字。他们将会以文本节点形式渲染到dom中。 Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。 null，什么也不渲染 布尔值。也是什么都不渲染，通常后跟组件进行判断。 当返回null,false,ReactDOM.findDOMNode(this)将会返回null，什么都不会渲染。 render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。如果shouldComponentUpdate()返回false，render()不会被调用。 Fragments你也可以在render()中使用数组，如：(不要忘记给每个数组元素添加key，防止出现警告)1234567render() &#123; return [ &lt;li key=\"A\"&gt;First item&lt;/li&gt;, &lt;li key=\"B\"&gt;Second item&lt;/li&gt;, &lt;li key=\"C\"&gt;Third item&lt;/li&gt;, ];&#125; 换一种写法，可以不写key（v16++）123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;/React.Fragment&gt; );&#125; 官方时钟示例: 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); 5.componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)官方建议使用getDerivedStateFromProps函数代替componentWillReceiveProps()。当组件挂载后，接收到新的props后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用this.setState()。 如果父组件会让这个组件重新渲染，即使props没有改变，也会调用这个方法。 react不会在组件初始化props时调用这个方法。调用this.setState也不会触发。 6.shouldComponentUpdate(nextProps, nextState)调用shouldComponentUpdate使react知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。 在渲染新的props或state前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在forceUpdate()时被调用。返回false不会阻止子组件在state更改时重新渲染。 如果shouldComponentUpdate()返回false，componentwillupdate,render和componentDidUpdate不会被调用。 在未来版本，shouldComponentUpdate()将会作为一个提示而不是严格的指令，返回false仍然可能导致组件的重新渲染。官方并不建议在shouldComponentUpdate()中进行深度查询或使用JSON.stringify()，他效率非常低，并且损伤性能。 7.UNSAFE_componentWillUpdate(nextProps, nextState)在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。 不能在这里使用this.setState()，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedStateFromProps。 8.getSnapshotBeforeUpdate()在react render()后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。 9.componentDidUpdate(prevProps, prevState, snapshot)在更新发生后立即调用componentDidUpdate()。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。 如果组件实现getSnapshotBeforeUpdate()生命周期，则它返回的值将作为第三个“快照”参数传递给componentDidUpdate()。否则，这个参数是undefined。 10.componentWillUnmount()在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount（）中创建的任何监听。 11.componentDidCatch(error, info)错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。 如果类组件定义了此生命周期方法，则它将成为错误边界。在它中调用setState()可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复;不要试图将它们用于控制流程。详细 错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。 参考文档 React v16.3.0: New lifecycles and context API React.Component mytac","categories":[{"name":"React","slug":"React","permalink":"https://yb909144903.github.io/categories/React/"}],"tags":[]},{"title":"给Hexo搭建的博客绑定域名","slug":"Hexo域名","date":"2018-12-02T07:25:54.000Z","updated":"2018-12-02T08:01:25.192Z","comments":true,"path":"2018/12/02/Hexo域名/","link":"","permalink":"https://yb909144903.github.io/2018/12/02/Hexo域名/","excerpt":"","text":"前言前几天利用闲置时间，利用hexo在GitHub上搭建了一个静态博客，那么既然是个人博客，当然要上自己的域名了。 step-1首先你得你得搭建 XXX.github.io 这样的博客，[hexo教程]。 step-2你的博客可以访问后，去阿里云、腾讯云等网站去注册个域名。 step-3获取博客的ip地址 Tips: 这一步主要为了解析域名，不获取IP的话，step4解析A类型就行 第一： clone 你创建的 仓库 xxx.github.io 第二： git的输入 ping www.xxx.github.io 得到IP 如下图： step-4等域名审核完后，和我相关的就来了。以下用阿里云注册的域名为例。进入阿里云的管理控制台-域名与网站-云解析DNS，进入域名的解析设置，点击新手指导，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现： 记录值就是自己 github 的二级域名的 IP地址。 Tips: 一般解析都需要点时间，等个20分钟左右就好了 step-5在hexo项目下 source 文件下创建CNAME 文件（没有后缀名的），在里面写上购买的域名，例如： step-6最后到你 xxx.github.io 的Settings里，填上你的域名 这样新域名就ok啦，可以访问了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yb909144903.github.io/categories/Hexo/"}],"tags":[]},{"title":"Git中遇到的大大小小的坑","slug":"Git","date":"2018-11-29T12:41:49.000Z","updated":"2018-11-29T12:44:41.931Z","comments":true,"path":"2018/11/29/Git/","link":"","permalink":"https://yb909144903.github.io/2018/11/29/Git/","excerpt":"","text":"目的：记录自己平时在项目中遇到的坑 Tips 不要在dev上操作。 更新git: git update- 1.windows清除git保存账号信息步骤因为做项目可能会用到不同的gitLab远程库，我的git默认是记住密码的，当时困扰了我好久，项目中的一个大佬，告诉的我这种方法。 开始菜单-&gt;控制面板-&gt;凭据管理器-&gt;windows凭据-&gt;从保管库中删除. 如图： 2.Git修改文件名大小写时不更新如果使用windows系统Coding，使用git时,如果一个文件只是把文件名的大小写改一下,提交后默认更新下来还是改之前的情况。通过谷歌，我找到以下两种方案。 通过修改”core.ignorecase false”来设置git大小写敏感.需要在提交端修改. git config core.ignorecase false 先删除文件再添加进去 git rmgit add.git commit -m “rename file” 终极解决方案 3.平时项目中git的基本操作 暂存修改的文件 git add [fileName] ——暂存某个文件git add . ——暂存所有修改的文件 撤销本地修改文件 git checkout [fileName] ——撤销某个文件git checkout . ——撤销所有修改的文件 提交暂存区文件 fix：修复bug update：更新文件 add：新增文件 modify：重命名 delete：删除文件 git commit -m “你的提交备注” 不想commit，那就储藏 git stash ——储藏git stash pop/apply ——弹出储藏 将本地仓库的代码推到远程分支 git push [远程分支名] 切换分支 git checkout [你要切换的分支名] 注释：切换分支之前，一定要将修改的文件提交或者放进储藏区 拉取远程分支代码 git pull orgin [分支名]git pull ——拉取当前分支的代码 合并分支 git merge [你要合并的分支名] 查看本地分支 git branch 查看远程分支 git branch -a 删除本地分支 git branch -d/-D [你要删除的分支] 删除远程分支 git branch orgin –delete [你要删除掉的分支] 查看提交记录 git loggit log -5 查看五条记录 查看被删除的提交记录 git reflog 回滚代码 git reset [commitId] 回滚代码但修改的代码还在git reset –hard [commitId] 回滚代码且修改的代码也没了 推送代码 git push orgin [当前分支]:devlop 连接远程仓库 git remote add origin 仓库地址仓库地址：https://git.coding.net/xxxxxxxxxxxxx/my-project.gitgit push -u orgin master 删除远程仓库 git remote remove origin 因为这篇文章属于我自己的记录，有的为别人博客的内容。侵权必删","categories":[{"name":"Git","slug":"Git","permalink":"https://yb909144903.github.io/categories/Git/"}],"tags":[]},{"title":"三分钟教你同步 visual studio code 设置","slug":"vscode","date":"2018-11-28T11:57:11.000Z","updated":"2018-11-29T08:28:51.808Z","comments":true,"path":"2018/11/28/vscode/","link":"","permalink":"https://yb909144903.github.io/2018/11/28/vscode/","excerpt":"","text":"简介Visual Studio Code(以下简称vsCode)现在已经渐渐成为前端开发的主力工具，谁让它这么轻便，功能又这么轻便呢。用vscode Coding的小伙伴们也一定会装很多插件吧。但是当你准备更换电脑的时候，是不是为迁移插件和设置而烦恼？我曾经换电脑的时候，把vsCode上自己心爱的插件一个个记下，然后去新电脑上重装，太蠢了。今天我就把vsCode同步设置和插件的方法告诉大家。 准备工作 下载Settings Sync插件 GitHub账号 1.安装Settings Sync Setting Sync 快捷键： 1) 上传： Shift + Alt + U (Sync: Update / Upload Settings) 2) 下载： Shift + Alt + D (Sync: Download Settings) 如果快捷键有冲突，可Ctrl + K + S快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择 2.打开GitHub 这样你就得到一个token，最好找个地方记下来。因为它就是同步设置的关键。 3.将token配置到vsCode(Sync: Update / Uplaod Settings) Shift + Alt + U 在弹窗里输入你的token， 回车后会生成syncSummary.txt文件 syncSummary.txt文件会存储VSCode的设置及所安装的插件列表 如果你使用的是新版本的vsCode 打开设置，在搜索框中输入sync，就可以看到自己的token了 4.设置同步下载设置(Sync: Download Settings) Shift + Alt + D 在弹窗里输入你的gist值，稍后片刻便可同步成功 5.如果要重置同步设置，变更其它tokenCtrl+P / F1 弹出输入&gt;sync,即可重新配置你的其它token来同步 6.Tips上传同步设置的时候，vsCode底下可以看到操作信息 Setting Sync 可同步包含的所有扩展和完整的用户文件夹 1) 设置文件 2) 快捷键设置文件 3) Launch File 4) Snippets Folder 5) VSCode 扩展设置 6) 工作空间 参考文章 Settings Sync更新说明","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://yb909144903.github.io/categories/工具资源/"}],"tags":[]},{"title":"测试Blog","slug":"index","date":"2018-11-27T11:57:11.000Z","updated":"2018-11-29T08:28:51.808Z","comments":true,"path":"2018/11/27/index/","link":"","permalink":"https://yb909144903.github.io/2018/11/27/index/","excerpt":"","text":"Welcom to Timbok’s Blog","categories":[{"name":"随身笔记","slug":"随身笔记","permalink":"https://yb909144903.github.io/categories/随身笔记/"}],"tags":[]}]}